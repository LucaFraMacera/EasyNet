import {
  __commonJS
} from "./chunk-RSJERJUL.js";

// node_modules/@tyriar/fibonacci-heap/lib/node.js
var require_node = __commonJS({
  "node_modules/@tyriar/fibonacci-heap/lib/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var Node = (
      /** @class */
      function() {
        function Node2(key, value) {
          this.parent = null;
          this.child = null;
          this.degree = 0;
          this.isMarked = false;
          this.key = key;
          this.value = value;
          this.prev = this;
          this.next = this;
        }
        return Node2;
      }()
    );
    exports.Node = Node;
  }
});

// node_modules/@tyriar/fibonacci-heap/lib/nodeListIterator.js
var require_nodeListIterator = __commonJS({
  "node_modules/@tyriar/fibonacci-heap/lib/nodeListIterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var NodeListIterator = (
      /** @class */
      function() {
        function NodeListIterator2(start) {
          this._index = -1;
          this._items = [];
          var current = start;
          do {
            this._items.push(current);
            current = current.next;
          } while (start !== current);
        }
        NodeListIterator2.prototype.hasNext = function() {
          return this._index < this._items.length - 1;
        };
        NodeListIterator2.prototype.next = function() {
          return this._items[++this._index];
        };
        return NodeListIterator2;
      }()
    );
    exports.NodeListIterator = NodeListIterator;
  }
});

// node_modules/@tyriar/fibonacci-heap/lib/fibonacciHeap.js
var require_fibonacciHeap = __commonJS({
  "node_modules/@tyriar/fibonacci-heap/lib/fibonacciHeap.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var node_1 = require_node();
    var nodeListIterator_1 = require_nodeListIterator();
    var FibonacciHeap = (
      /** @class */
      function() {
        function FibonacciHeap2(compare) {
          this._minNode = null;
          this._nodeCount = 0;
          this._compare = compare ? compare : this._defaultCompare;
        }
        FibonacciHeap2.prototype.clear = function() {
          this._minNode = null;
          this._nodeCount = 0;
        };
        FibonacciHeap2.prototype.decreaseKey = function(node, newKey) {
          if (!node) {
            throw new Error("Cannot decrease key of non-existent node");
          }
          if (this._compare({ key: newKey }, { key: node.key }) > 0) {
            throw new Error("New key is larger than old key");
          }
          node.key = newKey;
          var parent = node.parent;
          if (parent && this._compare(node, parent) < 0) {
            this._cut(node, parent, this._minNode);
            this._cascadingCut(parent, this._minNode);
          }
          if (this._compare(node, this._minNode) < 0) {
            this._minNode = node;
          }
        };
        FibonacciHeap2.prototype.delete = function(node) {
          var parent = node.parent;
          if (parent) {
            this._cut(node, parent, this._minNode);
            this._cascadingCut(parent, this._minNode);
          }
          this._minNode = node;
          this.extractMinimum();
        };
        FibonacciHeap2.prototype.extractMinimum = function() {
          var extractedMin = this._minNode;
          if (extractedMin) {
            if (extractedMin.child) {
              var child = extractedMin.child;
              do {
                child.parent = null;
                child = child.next;
              } while (child !== extractedMin.child);
            }
            var nextInRootList = null;
            if (extractedMin.next !== extractedMin) {
              nextInRootList = extractedMin.next;
            }
            this._removeNodeFromList(extractedMin);
            this._nodeCount--;
            this._minNode = this._mergeLists(nextInRootList, extractedMin.child);
            if (this._minNode) {
              this._minNode = this._consolidate(this._minNode);
            }
          }
          return extractedMin;
        };
        FibonacciHeap2.prototype.findMinimum = function() {
          return this._minNode;
        };
        FibonacciHeap2.prototype.insert = function(key, value) {
          var node = new node_1.Node(key, value);
          this._minNode = this._mergeLists(this._minNode, node);
          this._nodeCount++;
          return node;
        };
        FibonacciHeap2.prototype.isEmpty = function() {
          return this._minNode === null;
        };
        FibonacciHeap2.prototype.size = function() {
          if (this._minNode === null) {
            return 0;
          }
          return this._getNodeListSize(this._minNode);
        };
        FibonacciHeap2.prototype.union = function(other) {
          this._minNode = this._mergeLists(this._minNode, other._minNode);
          this._nodeCount += other._nodeCount;
        };
        FibonacciHeap2.prototype._defaultCompare = function(a, b) {
          if (a.key > b.key) {
            return 1;
          }
          if (a.key < b.key) {
            return -1;
          }
          return 0;
        };
        FibonacciHeap2.prototype._cut = function(node, parent, minNode) {
          node.parent = null;
          parent.degree--;
          if (node.next === node) {
            parent.child = null;
          } else {
            parent.child = node.next;
          }
          this._removeNodeFromList(node);
          var newMinNode = this._mergeLists(minNode, node);
          node.isMarked = false;
          return newMinNode;
        };
        FibonacciHeap2.prototype._cascadingCut = function(node, minNode) {
          var parent = node.parent;
          if (parent) {
            if (node.isMarked) {
              minNode = this._cut(node, parent, minNode);
              minNode = this._cascadingCut(parent, minNode);
            } else {
              node.isMarked = true;
            }
          }
          return minNode;
        };
        FibonacciHeap2.prototype._consolidate = function(minNode) {
          var aux = [];
          var it = new nodeListIterator_1.NodeListIterator(minNode);
          while (it.hasNext()) {
            var current = it.next();
            var auxCurrent = aux[current.degree];
            while (auxCurrent) {
              if (this._compare(current, auxCurrent) > 0) {
                var temp = current;
                current = auxCurrent;
                auxCurrent = temp;
              }
              this._linkHeaps(auxCurrent, current);
              aux[current.degree] = null;
              current.degree++;
              auxCurrent = aux[current.degree];
            }
            aux[current.degree] = current;
          }
          var newMinNode = null;
          for (var i = 0; i < aux.length; i++) {
            var node = aux[i];
            if (node) {
              node.next = node;
              node.prev = node;
              newMinNode = this._mergeLists(newMinNode, node);
            }
          }
          return newMinNode;
        };
        FibonacciHeap2.prototype._removeNodeFromList = function(node) {
          var prev = node.prev;
          var next = node.next;
          prev.next = next;
          next.prev = prev;
          node.next = node;
          node.prev = node;
        };
        FibonacciHeap2.prototype._linkHeaps = function(max, min) {
          this._removeNodeFromList(max);
          min.child = this._mergeLists(max, min.child);
          max.parent = min;
          max.isMarked = false;
        };
        FibonacciHeap2.prototype._mergeLists = function(a, b) {
          if (!a) {
            if (!b) {
              return null;
            }
            return b;
          }
          if (!b) {
            return a;
          }
          var temp = a.next;
          a.next = b.next;
          a.next.prev = a;
          b.next = temp;
          b.next.prev = b;
          return this._compare(a, b) < 0 ? a : b;
        };
        FibonacciHeap2.prototype._getNodeListSize = function(node) {
          var count = 0;
          var current = node;
          do {
            count++;
            if (current.child) {
              count += this._getNodeListSize(current.child);
            }
            current = current.next;
          } while (current !== node);
          return count;
        };
        return FibonacciHeap2;
      }()
    );
    exports.FibonacciHeap = FibonacciHeap;
  }
});
export default require_fibonacciHeap();
/*! Bundled license information:

@tyriar/fibonacci-heap/lib/node.js:
  (**
   * @license
   * Copyright Daniel Imms <http://www.growingwiththeweb.com>
   * Released under MIT license. See LICENSE in the project root for details.
   *)

@tyriar/fibonacci-heap/lib/nodeListIterator.js:
  (**
   * @license
   * Copyright Daniel Imms <http://www.growingwiththeweb.com>
   * Released under MIT license. See LICENSE in the project root for details.
   *)

@tyriar/fibonacci-heap/lib/fibonacciHeap.js:
  (**
   * @license
   * Copyright Daniel Imms <http://www.growingwiththeweb.com>
   * Released under MIT license. See LICENSE in the project root for details.
   *)
*/
//# sourceMappingURL=@tyriar_fibonacci-heap.js.map
