{
  "version": 3,
  "sources": ["../../@tyriar/fibonacci-heap/src/node.ts", "../../@tyriar/fibonacci-heap/src/nodeListIterator.ts", "../../@tyriar/fibonacci-heap/src/fibonacciHeap.ts"],
  "sourcesContent": ["/**\n * @license\n * Copyright Daniel Imms <http://www.growingwiththeweb.com>\n * Released under MIT license. See LICENSE in the project root for details.\n */\n\nimport { INode } from '@tyriar/fibonacci-heap';\n\nexport class Node<K, V> implements INode<K, V> {\n  public key: K;\n  public value: V | undefined;\n  public prev: Node<K, V>;\n  public next: Node<K, V>;\n  public parent: Node<K, V> | null = null;\n  public child: Node<K, V> | null = null;\n\n  public degree: number = 0;\n  public isMarked: boolean = false;\n\n  constructor(key: K, value?: V) {\n    this.key = key;\n    this.value = value;\n    this.prev = this;\n    this.next = this;\n  }\n}\n", "/**\n * @license\n * Copyright Daniel Imms <http://www.growingwiththeweb.com>\n * Released under MIT license. See LICENSE in the project root for details.\n */\n\nimport { Node } from './node';\n\nexport class NodeListIterator<K, V> {\n  private _index: number;\n  private _items: Node<K, V>[];\n\n  /**\n   * Creates an Iterator used to simplify the consolidate() method. It works by\n   * making a shallow copy of the nodes in the root list and iterating over the\n   * shallow copy instead of the source as the source will be modified.\n   * @param start A node from the root list.\n   */\n  constructor(start: Node<K, V>) {\n    this._index = -1;\n    this._items = [];\n    let current = start;\n    do {\n      this._items.push(current);\n      current = current.next;\n    } while (start !== current);\n  }\n\n  /**\n   * @return Whether there is a next node in the iterator.\n   */\n  public hasNext(): boolean {\n    return this._index < this._items.length - 1;\n  }\n\n  /**\n   * @return The next node.\n   */\n  public next(): Node<K, V> {\n    return this._items[++this._index];\n  }\n}\n", "/**\n * @license\n * Copyright Daniel Imms <http://www.growingwiththeweb.com>\n * Released under MIT license. See LICENSE in the project root for details.\n */\n\nimport { Node } from './node';\nimport { NodeListIterator } from './nodeListIterator';\nimport { FibonacciHeap as FibonacciHeapApi, CompareFunction, INode } from '@tyriar/fibonacci-heap';\n\nexport class FibonacciHeap<K, V> implements FibonacciHeapApi<K, V> {\n  private _minNode: Node<K, V> | null = null;\n  private _nodeCount: number = 0;\n  private _compare: CompareFunction<K, V>;\n\n  constructor(\n    compare?: CompareFunction<K, V>\n  ) {\n    this._compare = compare ? compare : this._defaultCompare;\n  }\n\n  /**\n   * Clears the heap's data, making it an empty heap.\n   */\n  public clear(): void {\n    this._minNode = null;\n    this._nodeCount = 0;\n  }\n\n  /**\n   * Decreases a key of a node.\n   * @param node The node to decrease the key of.\n   * @param newKey The new key to assign to the node.\n   */\n  public decreaseKey(node: Node<K, V>, newKey: K): void {\n    if (!node) {\n      throw new Error('Cannot decrease key of non-existent node');\n    }\n    if (this._compare({key: newKey}, {key: node.key}) > 0) {\n      throw new Error('New key is larger than old key');\n    }\n\n    node.key = newKey;\n    const parent = node.parent;\n    if (parent && this._compare(node, parent) < 0) {\n      this._cut(node, parent, <Node<K, V>>this._minNode);\n      this._cascadingCut(parent, <Node<K, V>>this._minNode);\n    }\n    if (this._compare(node, <Node<K, V>>this._minNode) < 0) {\n      this._minNode = node;\n    }\n  }\n\n  /**\n   * Deletes a node.\n   * @param node The node to delete.\n   */\n  public delete(node: Node<K, V>): void {\n    // This is a special implementation of decreaseKey that sets the argument to\n    // the minimum value. This is necessary to make generic keys work, since there\n    // is no MIN_VALUE constant for generic types.\n    const parent = node.parent;\n    if (parent) {\n      this._cut(node, parent, <Node<K, V>>this._minNode);\n      this._cascadingCut(parent, <Node<K, V>>this._minNode);\n    }\n    this._minNode = node;\n\n    this.extractMinimum();\n  }\n\n  /**\n   * Extracts and returns the minimum node from the heap.\n   * @return The heap's minimum node or null if the heap is empty.\n   */\n  public extractMinimum(): Node<K, V> | null {\n    const extractedMin = this._minNode;\n    if (extractedMin) {\n      // Set parent to null for the minimum's children\n      if (extractedMin.child) {\n        let child = extractedMin.child;\n        do {\n          child.parent = null;\n          child = child.next;\n        } while (child !== extractedMin.child);\n      }\n\n      let nextInRootList = null;\n      if (extractedMin.next !== extractedMin) {\n        nextInRootList = extractedMin.next;\n      }\n      // Remove min from root list\n      this._removeNodeFromList(extractedMin);\n      this._nodeCount--;\n\n      // Merge the children of the minimum node with the root list\n      this._minNode = this._mergeLists(nextInRootList, extractedMin.child);\n      if (this._minNode) {\n        this._minNode = this._consolidate(this._minNode);\n      }\n    }\n    return extractedMin;\n  }\n\n  /**\n   * Returns the minimum node from the heap.\n   * @return The heap's minimum node or null if the heap is empty.\n   */\n  public findMinimum(): Node<K, V> | null {\n    return this._minNode;\n  }\n\n  /**\n   * Inserts a new key-value pair into the heap.\n   * @param key The key to insert.\n   * @param value The value to insert.\n   * @return node The inserted node.\n   */\n  public insert(key: K, value?: V): Node<K, V> {\n    const node = new Node(key, value);\n    this._minNode = this._mergeLists(this._minNode, node);\n    this._nodeCount++;\n    return node;\n  }\n\n  /**\n   * @return Whether the heap is empty.\n   */\n  public isEmpty(): boolean {\n    return this._minNode === null;\n  }\n\n  /**\n   * @return The size of the heap.\n   */\n  public size(): number {\n    if (this._minNode === null) {\n      return 0;\n    }\n    return this._getNodeListSize(this._minNode);\n  }\n\n  /**\n   * Joins another heap to this heap.\n   * @param other The other heap.\n   */\n  public union(other: FibonacciHeap<K, V>): void {\n    this._minNode = this._mergeLists(this._minNode, other._minNode);\n    this._nodeCount += other._nodeCount;\n  }\n\n  /**\n   * Compares two nodes with each other.\n   * @param a The first key to compare.\n   * @param b The second key to compare.\n   * @return -1, 0 or 1 if a < b, a == b or a > b respectively.\n   */\n  private _defaultCompare(a: INode<K, V>, b: INode<K, V>): number {\n    if (a.key > b.key) {\n      return 1;\n    }\n    if (a.key < b.key) {\n      return -1;\n    }\n    return 0;\n  }\n\n  /**\n   * Cut the link between a node and its parent, moving the node to the root list.\n   * @param node The node being cut.\n   * @param parent The parent of the node being cut.\n   * @param minNode The minimum node in the root list.\n   * @return The heap's new minimum node.\n   */\n  private _cut(node: Node<K, V>, parent: Node<K, V>, minNode: Node<K, V>): Node<K, V> | null {\n    node.parent = null;\n    parent.degree--;\n    if (node.next === node) {\n      parent.child = null;\n    } else {\n      parent.child = node.next;\n    }\n    this._removeNodeFromList(node);\n    const newMinNode = this._mergeLists(minNode, node);\n    node.isMarked = false;\n    return newMinNode;\n  }\n\n  /**\n   * Perform a cascading cut on a node; mark the node if it is not marked,\n   * otherwise cut the node and perform a cascading cut on its parent.\n   * @param node The node being considered to be cut.\n   * @param minNode The minimum node in the root list.\n   * @return The heap's new minimum node.\n   */\n  private _cascadingCut(node: Node<K, V>, minNode: Node<K, V> | null): Node<K, V> | null {\n    const parent = node.parent;\n    if (parent) {\n      if (node.isMarked) {\n        minNode = this._cut(node, parent, <Node<K, V>>minNode);\n        minNode = this._cascadingCut(parent, minNode);\n      } else {\n        node.isMarked = true;\n      }\n    }\n    return minNode;\n  }\n\n  /**\n   * Merge all trees of the same order together until there are no two trees of\n   * the same order.\n   * @param minNode The current minimum node.\n   * @return The new minimum node.\n   */\n  private _consolidate(minNode: Node<K, V>): Node<K, V> | null {\n\n    const aux = [];\n    const it = new NodeListIterator<K, V>(minNode);\n    while (it.hasNext()) {\n      let current = it.next();\n\n      // If there exists another node with the same degree, merge them\n      let auxCurrent = aux[current.degree];\n      while (auxCurrent) {\n        if (this._compare(current, auxCurrent) > 0) {\n          const temp = current;\n          current = auxCurrent;\n          auxCurrent = temp;\n        }\n        this._linkHeaps(auxCurrent, current);\n        aux[current.degree] = null;\n        current.degree++;\n        auxCurrent = aux[current.degree];\n      }\n\n      aux[current.degree] = current;\n    }\n\n    let newMinNode = null;\n    for (let i = 0; i < aux.length; i++) {\n      const node = aux[i];\n      if (node) {\n        // Remove siblings before merging\n        node.next = node;\n        node.prev = node;\n        newMinNode = this._mergeLists(newMinNode, node);\n      }\n    }\n    return newMinNode;\n  }\n\n  /**\n   * Removes a node from a node list.\n   * @param node The node to remove.\n   */\n  private _removeNodeFromList(node: Node<K, V>): void {\n    const prev = node.prev;\n    const next = node.next;\n    prev.next = next;\n    next.prev = prev;\n    node.next = node;\n    node.prev = node;\n  }\n\n  /**\n   * Links two heaps of the same order together.\n   *\n   * @private\n   * @param max The heap with the larger root.\n   * @param min The heap with the smaller root.\n   */\n  private _linkHeaps(max: Node<K, V>, min: Node<K, V>): void {\n    this._removeNodeFromList(max);\n    min.child = this._mergeLists(max, min.child);\n    max.parent = min;\n    max.isMarked = false;\n  }\n\n  /**\n   * Merge two lists of nodes together.\n   *\n   * @private\n   * @param a The first list to merge.\n   * @param b The second list to merge.\n   * @return The new minimum node from the two lists.\n   */\n  private _mergeLists(a: Node<K, V> | null, b: Node<K, V> | null): Node<K, V> | null {\n    if (!a) {\n      if (!b) {\n        return null;\n      }\n      return b;\n    }\n    if (!b) {\n      return a;\n    }\n\n    const temp = a.next;\n    a.next = b.next;\n    a.next.prev = a;\n    b.next = temp;\n    b.next.prev = b;\n\n    return this._compare(a, b) < 0 ? a : b;\n  }\n\n  /**\n   * Gets the size of a node list.\n   * @param node A node within the node list.\n   * @return The size of the node list.\n   */\n  private _getNodeListSize(node: Node<K, V>): number {\n    let count = 0;\n    let current = node;\n\n    do {\n      count++;\n      if (current.child) {\n        count += this._getNodeListSize(current.child);\n      }\n      current = current.next;\n    } while (current !== node);\n\n    return count;\n  }\n}\n"],
  "mappings": "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",
  "names": ["Node", "NodeListIterator", "FibonacciHeap"]
}
